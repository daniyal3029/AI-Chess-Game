"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS = CryptoJS || (function(Math2, undefined) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || /* @__PURE__ */ (function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        })();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ (function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        })();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      })(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// src/main.js
var main_exports = {};
__export(main_exports, {
  create: () => create,
  createSimple: () => createSimple,
  createUCI: () => createUCI,
  default: () => main_default,
  fromFEN: () => fromFEN
});
module.exports = __toCommonJS(main_exports);

// src/algebraicGameClient.js
var import_events3 = require("events");

// src/piece.js
var PieceType = {
  Bishop: "bishop",
  King: "king",
  Knight: "knight",
  Pawn: "pawn",
  Queen: "queen",
  Rook: "rook"
};
var SideType = {
  Black: { name: "black" },
  White: { name: "white" }
};
var Piece = class {
  constructor(side, notation) {
    this.moveCount = 0;
    this.notation = notation;
    this.side = side;
    this.type = null;
  }
  static createBishop(side) {
    return new Bishop(side);
  }
  static createKing(side) {
    return new King(side);
  }
  static createKnight(side) {
    return new Knight(side);
  }
  static createPawn(side) {
    return new Pawn(side);
  }
  static createQueen(side) {
    return new Queen(side);
  }
  static createRook(side) {
    return new Rook(side);
  }
};
var Bishop = class extends Piece {
  constructor(side) {
    super(side, "B");
    this.type = PieceType.Bishop;
  }
};
var King = class extends Piece {
  constructor(side) {
    super(side, "K");
    this.type = PieceType.King;
  }
};
var Knight = class extends Piece {
  constructor(side) {
    super(side, "N");
    this.type = PieceType.Knight;
  }
};
var Pawn = class extends Piece {
  constructor(side) {
    super(side, "");
    this.type = PieceType.Pawn;
  }
};
var Queen = class extends Piece {
  constructor(side) {
    super(side, "Q");
    this.type = PieceType.Queen;
  }
};
var Rook = class extends Piece {
  constructor(side) {
    super(side, "R");
    this.type = PieceType.Rook;
  }
};

// src/board.js
var import_events = require("events");

// src/square.js
var Square = class _Square {
  constructor(file, rank) {
    this.file = file;
    this.piece = null;
    this.rank = rank;
  }
  static create(file, rank) {
    return new _Square(file, rank);
  }
};

// src/board.js
var NeighborType = {
  Above: { offset: 8 },
  AboveLeft: { offset: 7 },
  AboveRight: { offset: 9 },
  Below: { offset: -8 },
  BelowLeft: { offset: -9 },
  BelowRight: { offset: -7 },
  KnightAboveLeft: { offset: 15 },
  KnightAboveRight: { offset: 17 },
  KnightBelowLeft: { offset: -17 },
  KnightBelowRight: { offset: -15 },
  KnightLeftAbove: { offset: 6 },
  KnightLeftBelow: { offset: -10 },
  KnightRightAbove: { offset: 10 },
  KnightRightBelow: { offset: -6 },
  Left: { offset: -1 },
  Right: { offset: 1 }
};
var Board = class _Board extends import_events.EventEmitter {
  constructor(squares) {
    super();
    this.squares = squares;
  }
  static create() {
    let b = new _Board([]), f = 0, i = 0, r = 0, sq = null;
    for (i = 0; i < 64; i++) {
      f = Math.floor(i % 8);
      r = Math.floor(i / 8) + 1;
      sq = Square.create("abcdefgh"[f], r);
      b.squares.push(sq);
      if (r === 1 || r === 8) {
        if (f === 0 || f === 7) {
          sq.piece = Piece.createRook(
            r === 1 ? SideType.White : SideType.Black
          );
        } else if (f === 1 || f === 6) {
          sq.piece = Piece.createKnight(
            r === 1 ? SideType.White : SideType.Black
          );
        } else if (f === 2 || f === 5) {
          sq.piece = Piece.createBishop(
            r === 1 ? SideType.White : SideType.Black
          );
        } else if (f === 3) {
          sq.piece = Piece.createQueen(
            r === 1 ? SideType.White : SideType.Black
          );
        } else {
          sq.piece = Piece.createKing(
            r === 1 ? SideType.White : SideType.Black
          );
        }
      } else if (r === 2 || r === 7) {
        sq.piece = Piece.createPawn(
          r === 2 ? SideType.White : SideType.Black
        );
      }
    }
    return b;
  }
  static load(fen) {
    const pieces = {
      b: { arg: SideType.Black, method: "createBishop" },
      B: { arg: SideType.White, method: "createBishop" },
      k: { arg: SideType.Black, method: "createKing" },
      K: { arg: SideType.White, method: "createKing" },
      n: { arg: SideType.Black, method: "createKnight" },
      N: { arg: SideType.White, method: "createKnight" },
      p: { arg: SideType.Black, method: "createPawn" },
      P: { arg: SideType.White, method: "createPawn" },
      q: { arg: SideType.Black, method: "createQueen" },
      Q: { arg: SideType.White, method: "createQueen" },
      r: { arg: SideType.Black, method: "createRook" },
      R: { arg: SideType.White, method: "createRook" }
    };
    const [
      board
      /* , turn, castling, enPassant, halfs, moves */
    ] = fen.split(" ");
    const lines = board.split("/").map((line, rank) => {
      const arr = line.split("");
      let file = 0;
      return arr.reduce((acc, cur) => {
        if (!isNaN(Number(cur))) {
          for (let i = 0; i < Number(cur); i += 1) {
            acc.push(Square.create("abcdefgh"[file], 8 - rank));
            file = file < 7 ? file + 1 : 0;
          }
        } else {
          const square = Square.create("abcdefgh"[file], 8 - rank);
          square.piece = Piece[pieces[cur].method](pieces[cur].arg);
          acc.push(square);
          file = file < 7 ? file + 1 : 0;
        }
        return acc;
      }, []);
    });
    return new _Board(lines.reduce((acc, cur) => {
      acc.push(...cur);
      return acc;
    }, []));
  }
  getFen() {
    const fen = [];
    const squares = this.squares.reduce((acc, cur, idx) => {
      const outerIdx = parseInt(idx / 8, 10);
      acc[outerIdx] = acc[outerIdx] || [];
      acc[outerIdx].push(cur);
      return acc;
    }, []).flatMap((row) => row.reverse()).reverse();
    for (let i = 0; i < squares.length; i += 1) {
      const square = squares[i];
      if (square.file === "a" && square.rank < 8) {
        fen.push("/");
      }
      if (square.piece) {
        const transform = `to${square.piece.side.name === "white" ? "Upp" : "Low"}erCase`;
        fen.push((square.piece.notation || "p")[transform]());
      } else {
        if (isNaN(Number(fen[fen.length - 1]))) {
          fen.push(1);
        } else {
          fen[fen.length - 1] += 1;
        }
      }
    }
    return fen.join("");
  }
  getNeighborSquare(sq, n) {
    if (sq && n) {
      if (sq.file === "a" && (n === NeighborType.AboveLeft || n === NeighborType.BelowLeft || n === NeighborType.Left)) {
        return null;
      }
      if (sq.file === "h" && (n === NeighborType.AboveRight || n === NeighborType.BelowRight || n === NeighborType.Right)) {
        return null;
      }
      if (sq.rank === 1 && (n === NeighborType.Below || n === NeighborType.BelowLeft || n === NeighborType.BelowRight)) {
        return null;
      }
      if (sq.rank === 8 && (n === NeighborType.Above || n === NeighborType.AboveLeft || n === NeighborType.AboveRight)) {
        return null;
      }
      let fIndex = "abcdefgh".indexOf(sq.file), i = 0;
      if (fIndex !== -1 && sq.rank > 0 && sq.rank < 9) {
        i = 8 * (sq.rank - 1) + fIndex + n.offset;
        if (this.squares && this.squares.length > i && i > -1) {
          return this.squares[i];
        }
      }
    }
    return null;
  }
  getSquare(f, r) {
    if (typeof f === "string" && f.length === 2 && !r) {
      r = parseInt(f.charAt(1), 10);
      f = f.charAt(0);
    }
    let fIndex = "abcdefgh".indexOf(f), i = 0;
    if (fIndex !== -1 && r > 0 && r < 9) {
      i = 8 * (r - 1) + fIndex;
      if (this.squares && this.squares.length > i) {
        return this.squares[i];
      }
    }
    return null;
  }
  getSquares(side) {
    const list = [];
    for (let i = 0; i < this.squares.length; i++) {
      if (this.squares[i].piece && this.squares[i].piece.side === side) {
        list.push(this.squares[i]);
      }
    }
    return list;
  }
  move(src, dest, n) {
    if (typeof src === "string" && src.length === 2) {
      src = this.getSquare(src);
    }
    if (typeof dest === "string" && dest.length === 2) {
      dest = this.getSquare(dest);
    }
    let simulate;
    if (typeof n === "boolean") {
      simulate = n;
      n = null;
    }
    if (src && src.file && src.rank && dest && dest.file && dest.rank) {
      let move = {
        algebraic: n,
        capturedPiece: dest.piece,
        castle: false,
        enPassant: false,
        postSquare: dest,
        prevSquare: src
      }, p = src.piece, sq = null, undo = (b, m) => {
        return () => {
          if (!simulate) {
            if (m.undone) {
              throw new Error("cannot undo a move multiple times");
            }
          }
          m.prevSquare.piece = m.postSquare.piece;
          m.postSquare.piece = m.capturedPiece;
          if (!m.enPassant) {
            m.postSquare.piece = m.capturedPiece;
          }
          if (m.enPassant) {
            b.getSquare(
              m.postSquare.file,
              m.prevSquare.rank
            ).piece = m.capturedPiece;
            m.postSquare.piece = null;
          }
          if (m.castle) {
            sq = b.getSquare(
              move.postSquare.file === "g" ? "f" : "d",
              move.postSquare.rank
            );
            b.getSquare(
              move.postSquare.file === "g" ? "h" : "a",
              move.postSquare.rank
            ).piece = sq.piece;
            sq.piece = null;
          }
          if (!simulate) {
            m.prevSquare.piece.moveCount = m.prevSquare.piece.moveCount - 1;
            m.undone = true;
            b.emit("undo", m);
          }
        };
      };
      dest.piece = p;
      move.castle = p.type === PieceType.King && p.moveCount === 0 && (move.postSquare.file === "g" || move.postSquare.file === "c");
      move.enPassant = p.type === PieceType.Pawn && move.capturedPiece === null && move.postSquare.file !== move.prevSquare.file;
      move.prevSquare.piece = null;
      if (move.enPassant) {
        sq = this.getSquare(move.postSquare.file, move.prevSquare.rank);
        move.capturedPiece = sq.piece;
        sq.piece = null;
      }
      if (move.castle) {
        sq = this.getSquare(
          move.postSquare.file === "g" ? "h" : "a",
          move.postSquare.rank
        );
        if (sq.piece === null) {
          move.castle = false;
        } else {
          this.getSquare(
            move.postSquare.file === "g" ? "f" : "d",
            move.postSquare.rank
          ).piece = sq.piece;
          sq.piece = null;
        }
      }
      if (!simulate) {
        p.moveCount++;
        this.lastMovedPiece = p;
        if (move.capturedPiece) {
          this.emit("capture", move);
        }
        if (move.castle) {
          this.emit("castle", move);
        }
        if (move.enPassant) {
          this.emit("enPassant", move);
        }
        this.emit("move", move);
      }
      return {
        move,
        undo: undo(this, move)
      };
    }
  }
  promote(sq, p) {
    p.moveCount = sq.piece.moveCount;
    this.lastMovedPiece = p;
    sq.piece = p;
    this.emit("promote", sq);
    return sq;
  }
};

// src/game.js
var import_enc_base64 = __toESM(require_enc_base64(), 1);
var import_events2 = require("events");
var import_md5 = __toESM(require_md5(), 1);
function addToHistory(game) {
  return (ev) => {
    let hashCode = game.getHashCode(), move = new Move(
      ev.prevSquare,
      ev.postSquare,
      ev.capturedPiece,
      ev.algebraic,
      ev.castle,
      ev.enPassant,
      hashCode
    );
    game.moveHistory.push(move);
  };
}
function denotePromotionInHistory(game) {
  return () => {
    let latest = game.moveHistory[game.moveHistory.length - 1];
    if (latest) {
      latest.promotion = true;
    }
  };
}
function removeFromHistory(game) {
  return () => {
    game.moveHistory.pop();
    let m = game.moveHistory[game.moveHistory.length - 1];
    if (m) {
      game.board.lastMovedPiece = m.piece;
    }
  };
}
var Game = class _Game extends import_events2.EventEmitter {
  constructor(board) {
    super();
    this.board = board;
    this.captureHistory = [];
    this.moveHistory = [];
  }
  static create() {
    let board = Board.create(), game = new _Game(board);
    board.on("move", (ev) => {
      addToHistory(game)(ev);
      if (ev && ev.capturedPiece) {
        game.captureHistory.push(ev.capturedPiece);
      }
    });
    board.on("promote", denotePromotionInHistory(game));
    board.on("undo", (ev) => {
      removeFromHistory(game)(ev);
      if (ev && ev.capturedPiece && game.captureHistory.length > 0) {
        game.captureHistory.pop();
      }
    });
    return game;
  }
  getCurrentSide() {
    return this.moveHistory.length % 2 === 0 ? SideType.White : SideType.Black;
  }
  getHashCode() {
    let i = 0, sum = "";
    for (i = 0; i < this.board.squares.length; i++) {
      if (this.board.squares[i].piece !== null) {
        sum += [
          this.board.squares[i].file,
          this.board.squares[i].rank,
          this.board.squares[i].piece.side === SideType.White ? "w" : "b",
          this.board.squares[i].piece.notation,
          i < this.board.squares.length - 1 ? "-" : ""
        ].join("");
      }
    }
    let digest = (0, import_md5.default)(sum);
    return import_enc_base64.default.stringify(digest);
  }
  static load(moveHistory) {
    let board = Board.create(), game = new _Game(board), i = 0;
    board.on("move", (ev) => {
      addToHistory(game)(ev);
      if (ev && ev.capturedPiece) {
        game.captureHistory.push(ev.capturedPiece);
      }
    });
    board.on("promote", denotePromotionInHistory(game));
    for (i = 0; i < moveHistory.length; i++) {
      board.move(
        board.getSquare(
          moveHistory[i].prevFile,
          moveHistory[i].prevRank
        ),
        board.getSquare(
          moveHistory[i].postFile,
          moveHistory[i].postRank
        )
      );
    }
    return game;
  }
};
var Move = class {
  constructor(originSquare, targetSquare, capturedPiece, notation, castle, enPassant, hash) {
    this.algebraic = notation;
    this.capturedPiece = capturedPiece;
    this.castle = castle;
    this.enPassant = enPassant;
    this.hashCode = hash;
    this.piece = targetSquare.piece;
    this.promotion = false;
    this.postFile = targetSquare.file;
    this.postRank = targetSquare.rank;
    this.prevFile = originSquare.file;
    this.prevRank = originSquare.rank;
  }
};

// src/pieceValidation.js
var PieceValidation = class {
  constructor(board) {
    this.allowBackward = false;
    this.allowDiagonal = false;
    this.allowForward = false;
    this.allowHorizontal = false;
    this.board = board;
    this.type = null;
    this.repeat = 0;
  }
  applySpecialValidation() {
  }
  static create(piece, board) {
    switch (piece) {
      case PieceType.Bishop:
        return new BishopValidation(board);
      case PieceType.King:
        return new KingValidation(board);
      case PieceType.Knight:
        return new KnightValidation(board);
      case PieceType.Pawn:
        return new PawnValidation(board);
      case PieceType.Queen:
        return new QueenValidation(board);
      case PieceType.Rook:
        return new RookValidation(board);
      default:
        return null;
    }
  }
  start(src, callback) {
    callback = callback || ((err, destinationSquares) => new Promise((resolve, reject) => {
      if (err) {
        return reject(err);
      }
      return resolve(destinationSquares);
    }));
    let opt = {
      destSquares: [],
      origin: src,
      piece: src ? src.piece : null
    };
    const findMoveOptions = function(b, r, n) {
      let block = false, capture = false, currentSquare = b.getNeighborSquare(opt.origin, n), i = 0;
      while (currentSquare && i < r) {
        block = currentSquare.piece !== null && (opt.piece.type === PieceType.Pawn || currentSquare.piece.side === opt.piece.side);
        capture = currentSquare.piece && !block;
        if (!block) {
          opt.destSquares.push(currentSquare);
        }
        if (capture || block) {
          currentSquare = null;
        } else {
          currentSquare = b.getNeighborSquare(currentSquare, n);
          i++;
        }
      }
    };
    if (!opt.piece || opt.piece.type !== this.type) {
      return callback(new Error("piece is invalid"));
    }
    if (this.board && opt.origin) {
      if (this.allowForward) {
        findMoveOptions(
          this.board,
          this.repeat,
          opt.piece.side === SideType.White ? NeighborType.Above : NeighborType.Below
        );
      }
      if (this.allowBackward) {
        findMoveOptions(
          this.board,
          this.repeat,
          opt.piece.side === SideType.White ? NeighborType.Below : NeighborType.Above
        );
      }
      if (this.allowHorizontal) {
        findMoveOptions(this.board, this.repeat, NeighborType.Left);
        findMoveOptions(this.board, this.repeat, NeighborType.Right);
      }
      if (this.allowDiagonal) {
        findMoveOptions(this.board, this.repeat, NeighborType.AboveLeft);
        findMoveOptions(this.board, this.repeat, NeighborType.BelowRight);
        findMoveOptions(this.board, this.repeat, NeighborType.BelowLeft);
        findMoveOptions(this.board, this.repeat, NeighborType.AboveRight);
      }
      this.applySpecialValidation(opt);
      return callback(null, opt.destSquares);
    }
    return callback(new Error("board is invalid"));
  }
};
var BishopValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.allowDiagonal = true;
    this.type = PieceType.Bishop;
    this.repeat = 8;
  }
};
var KingValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.allowBackward = true;
    this.allowDiagonal = true;
    this.allowForward = true;
    this.allowHorizontal = true;
    this.type = PieceType.King;
    this.repeat = 1;
  }
  applySpecialValidation() {
  }
};
var KnightValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.type = PieceType.Knight;
    this.repeat = 1;
  }
  applySpecialValidation(opt) {
    let aboveLeft = this.board.getNeighborSquare(
      opt.origin,
      NeighborType.AboveLeft
    ), aboveRight = this.board.getNeighborSquare(
      opt.origin,
      NeighborType.AboveRight
    ), belowLeft = this.board.getNeighborSquare(
      opt.origin,
      NeighborType.BelowLeft
    ), belowRight = this.board.getNeighborSquare(
      opt.origin,
      NeighborType.BelowRight
    ), i = 0, p = null, squares = [];
    if (aboveLeft) {
      squares.push(this.board.getNeighborSquare(
        aboveLeft,
        NeighborType.Above
      ));
      squares.push(this.board.getNeighborSquare(
        aboveLeft,
        NeighborType.Left
      ));
    }
    if (aboveRight) {
      squares.push(this.board.getNeighborSquare(
        aboveRight,
        NeighborType.Above
      ));
      squares.push(this.board.getNeighborSquare(
        aboveRight,
        NeighborType.Right
      ));
    }
    if (belowLeft) {
      squares.push(this.board.getNeighborSquare(
        belowLeft,
        NeighborType.Below
      ));
      squares.push(this.board.getNeighborSquare(
        belowLeft,
        NeighborType.Left
      ));
    }
    if (belowRight) {
      squares.push(this.board.getNeighborSquare(
        belowRight,
        NeighborType.Below
      ));
      squares.push(this.board.getNeighborSquare(
        belowRight,
        NeighborType.Right
      ));
    }
    for (i = 0; i < squares.length; i++) {
      if (squares[i]) {
        p = squares[i] ? squares[i].piece : null;
        if (!p || p.side !== opt.piece.side) {
          opt.destSquares.push(squares[i]);
        }
      }
    }
  }
};
var PawnValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.allowForward = true;
    this.type = PieceType.Pawn;
    this.repeat = 1;
  }
  /* eslint no-magic-numbers:0 */
  applySpecialValidation(opt) {
    let i = 0, p = null, sq = null, squares = [
      this.board.getNeighborSquare(
        opt.origin,
        opt.piece.side === SideType.White ? NeighborType.AboveLeft : NeighborType.BelowLeft
      ),
      this.board.getNeighborSquare(
        opt.origin,
        opt.piece.side === SideType.White ? NeighborType.AboveRight : NeighborType.BelowRight
      )
    ];
    for (i = 0; i < squares.length; i++) {
      p = squares[i] ? squares[i].piece : null;
      if (p && p.side !== opt.piece.side) {
        opt.destSquares.push(squares[i]);
      }
    }
    if (opt.piece.moveCount === 0 && opt.destSquares.length && // Fix for issue #15 (originally looked for length of 1)
    opt.destSquares[0].piece === null) {
      sq = this.board.getNeighborSquare(
        opt.destSquares[0],
        opt.piece.side === SideType.White ? NeighborType.Above : NeighborType.Below
      );
      if (!sq.piece) {
        opt.destSquares.push(sq);
      }
    } else if (opt.origin.rank === (opt.piece.side === SideType.White ? 5 : 4)) {
      squares = [
        this.board.getNeighborSquare(opt.origin, NeighborType.Left),
        this.board.getNeighborSquare(opt.origin, NeighborType.Right)
      ];
      i = 0;
      for (i = 0; i < squares.length; i++) {
        p = squares[i] ? squares[i].piece : null;
        if (p && p.type === PieceType.Pawn && p.side !== opt.piece.side && p.moveCount === 1 && this.board.lastMovedPiece === p) {
          opt.destSquares.push(
            this.board.getNeighborSquare(
              squares[i],
              p.side === SideType.Black ? NeighborType.Above : NeighborType.Below
            )
          );
        }
      }
    }
  }
};
var QueenValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.allowBackward = true;
    this.allowDiagonal = true;
    this.allowForward = true;
    this.allowHorizontal = true;
    this.repeat = 8;
    this.type = PieceType.Queen;
  }
};
var RookValidation = class extends PieceValidation {
  constructor(board) {
    super(board);
    this.allowBackward = true;
    this.allowForward = true;
    this.allowHorizontal = true;
    this.repeat = 8;
    this.type = PieceType.Rook;
  }
};

// src/boardValidation.js
var BoardValidation = class _BoardValidation {
  constructor(game) {
    this.board = game ? game.board : null;
    this.game = game;
  }
  static create(game) {
    return new _BoardValidation(game);
  }
  evaluateCastle(validMoves) {
    let getValidSquares = (sq) => {
      let i = 0;
      for (i = 0; i < validMoves.length; i++) {
        if (validMoves[i].src === sq) {
          return validMoves[i].squares;
        }
      }
    }, interimMove = null, rank = this.game.getCurrentSide() === SideType.White ? 1 : 8, squares = {
      "a": this.board.getSquare("a", rank),
      "b": this.board.getSquare("b", rank),
      "c": this.board.getSquare("c", rank),
      "d": this.board.getSquare("d", rank),
      "e": this.board.getSquare("e", rank),
      "f": this.board.getSquare("f", rank),
      "g": this.board.getSquare("g", rank),
      "h": this.board.getSquare("h", rank)
    };
    if (squares.e.piece && squares.e.piece.type === PieceType.King && squares.e.piece.moveCount === 0 && !this.isSquareAttacked(squares.e)) {
      if (squares.a.piece && squares.a.piece.type === PieceType.Rook && squares.a.piece.moveCount === 0) {
        if (!squares.b.piece && !squares.c.piece && !squares.d.piece) {
          interimMove = this.board.move(squares.e, squares.d, true);
          if (!this.isSquareAttacked(squares.d)) {
            interimMove.undo();
            interimMove = this.board.move(squares.e, squares.c, true);
            if (!this.isSquareAttacked(squares.c)) {
              getValidSquares(squares.e).push(squares.c);
            }
          }
          interimMove.undo();
        }
      }
      if (squares.h.piece && squares.h.piece.type === PieceType.Rook && squares.h.piece.moveCount === 0) {
        if (!squares.g.piece && !squares.f.piece) {
          interimMove = this.board.move(squares.e, squares.f, true);
          if (!this.isSquareAttacked(squares.f)) {
            interimMove.undo();
            interimMove = this.board.move(squares.e, squares.g, true);
            if (!this.isSquareAttacked(squares.g)) {
              getValidSquares(squares.e).push(squares.g);
            }
          }
          interimMove.undo();
        }
      }
    }
  }
  filterKingAttack(kingSquare, moves) {
    let filteredMoves = [], i = 0, isCheck = false, n = 0, r = null, squares = [];
    for (i = 0; i < moves.length; i++) {
      squares = [];
      for (n = 0; n < moves[i].squares.length; n++) {
        r = this.board.move(moves[i].src, moves[i].squares[n], true);
        if (moves[i].squares[n].piece.type !== PieceType.King) {
          isCheck = this.isSquareAttacked(kingSquare);
        } else {
          isCheck = this.isSquareAttacked(moves[i].squares[n]);
        }
        r.undo();
        if (!isCheck) {
          squares.push(moves[i].squares[n]);
        }
      }
      if (squares && squares.length > 0) {
        filteredMoves.push({
          squares,
          src: moves[i].src
        });
      }
    }
    return filteredMoves;
  }
  findAttackers(sq) {
    if (!sq || !sq.piece) {
      return {
        attacked: false,
        blocked: false
      };
    }
    let isAttacked = (b, n) => {
      let context = {}, currentSquare = b.getNeighborSquare(sq, n);
      while (currentSquare) {
        context = {
          attacked: currentSquare.piece && currentSquare.piece.side !== sq.piece.side,
          blocked: currentSquare.piece && currentSquare.piece.side === sq.piece.side,
          piece: currentSquare.piece,
          square: currentSquare
        };
        if (context.attacked) {
          PieceValidation.create(context.piece.type, b).start(currentSquare, setAttacked(context));
          currentSquare = null;
        } else if (context.blocked) {
          currentSquare = null;
        } else {
          currentSquare = b.getNeighborSquare(currentSquare, n);
        }
      }
      return context;
    }, isAttackedByKnight = (b, n) => {
      let context, currentSquare = b.getNeighborSquare(sq, n);
      context = {
        attacked: false,
        blocked: false,
        piece: currentSquare ? currentSquare.piece : currentSquare,
        square: currentSquare
      };
      if (currentSquare && currentSquare.piece && currentSquare.piece.type === PieceType.Knight) {
        PieceValidation.create(PieceType.Knight, b).start(currentSquare, setAttacked(context));
      }
      return context;
    }, self2 = this, setAttacked = (c) => {
      return (err, squares) => {
        if (!err) {
          let i = 0;
          for (i = 0; i < squares.length; i++) {
            if (squares[i] === sq) {
              c.attacked = true;
              return;
            }
          }
        }
        c.attacked = false;
      };
    };
    return [
      isAttacked(self2.board, NeighborType.Above),
      isAttacked(self2.board, NeighborType.AboveRight),
      isAttacked(self2.board, NeighborType.Right),
      isAttacked(self2.board, NeighborType.BelowRight),
      isAttacked(self2.board, NeighborType.Below),
      isAttacked(self2.board, NeighborType.BelowLeft),
      isAttacked(self2.board, NeighborType.Left),
      isAttacked(self2.board, NeighborType.AboveLeft),
      // fix for issue #4
      isAttackedByKnight(self2.board, NeighborType.KnightAboveRight),
      isAttackedByKnight(self2.board, NeighborType.KnightRightAbove),
      isAttackedByKnight(self2.board, NeighborType.KnightBelowRight),
      isAttackedByKnight(self2.board, NeighborType.KnightRightBelow),
      isAttackedByKnight(self2.board, NeighborType.KnightBelowLeft),
      isAttackedByKnight(self2.board, NeighborType.KnightLeftBelow),
      isAttackedByKnight(self2.board, NeighborType.KnightAboveLeft),
      isAttackedByKnight(self2.board, NeighborType.KnightLeftAbove)
    ].filter((result) => result.attacked);
  }
  isSquareAttacked(sq) {
    return this.findAttackers(sq).length !== 0;
  }
  start(callback) {
    callback = callback || ((err, validMoves2) => new Promise((resolve, reject) => {
      if (err) {
        return reject(err);
      }
      return resolve(validMoves2);
    }));
    let i = 0, kingSquare = null, setValidMoves = (v, sq) => {
      return (err, squares2) => {
        if (err) {
          return callback(err);
        }
        if (squares2 && squares2.length > 0) {
          v.push({
            squares: squares2,
            src: sq
          });
        }
      };
    }, squares = [], validMoves = [];
    if (this.board) {
      squares = this.board.getSquares(this.game.getCurrentSide());
      for (i = 0; i < squares.length; i++) {
        if (squares[i].piece.type === PieceType.King) {
          kingSquare = squares[i];
        }
        if (squares[i] && squares[i].piece) {
          PieceValidation.create(squares[i].piece.type, this.board).start(squares[i], setValidMoves(validMoves, squares[i]));
        }
      }
      this.evaluateCastle(validMoves);
      validMoves = this.filterKingAttack(kingSquare, validMoves);
      this.findAttackers(kingSquare).forEach((attacker) => {
        if (!validMoves.length) {
          this.game.emit(
            "checkmate",
            {
              attackingSquare: attacker.square,
              kingSquare
            }
          );
          return;
        }
        this.game.emit(
          "check",
          {
            attackingSquare: attacker.square,
            kingSquare
          }
        );
      });
    } else {
      return callback(new Error("board is invalid"));
    }
    return callback(null, validMoves);
  }
};

// src/gameValidation.js
var GameValidation = class _GameValidation {
  constructor(game) {
    this.game = game;
  }
  static create(game) {
    return new _GameValidation(game);
  }
  findKingSquare(side) {
    let i = 0, squares = this.game.board.getSquares(side);
    for (i = 0; i < squares.length; i++) {
      if (squares[i].piece.type === PieceType.King) {
        return squares[i];
      }
    }
  }
  isRepetition() {
    let hash = "", hashCount = [], i = 0;
    for (i = 0; i < this.game.moveHistory.length; i++) {
      hash = this.game.moveHistory[i].hashCode;
      hashCount[hash] = hashCount[hash] ? hashCount[hash] + 1 : 1;
      if (hashCount[hash] === 3) {
        return true;
      }
    }
    return false;
  }
  start(callback) {
    callback = callback || ((err, result2) => new Promise((resolve, reject) => {
      if (err) {
        return reject(err);
      }
      return resolve(result2);
    }));
    let kingSquare = null, result = {
      isCheck: false,
      isCheckmate: false,
      isFiftyMoveDraw: false,
      isRepetition: false,
      isStalemate: false,
      validMoves: []
    }, setResult = (v2, result2, isKingAttacked) => {
      return (err, validMoves) => {
        if (err) {
          return callback(err);
        }
        result2.isCheck = isKingAttacked && validMoves.length > 0;
        result2.isCheckmate = isKingAttacked && validMoves.length === 0;
        result2.isStalemate = !isKingAttacked && validMoves.length === 0;
        result2.isRepetition = v2.isRepetition();
        result2.validMoves = validMoves;
        return callback(null, result2);
      };
    }, v = BoardValidation.create(this.game);
    if (this.game) {
      kingSquare = this.findKingSquare(this.game.getCurrentSide());
      return v.start(setResult(this, result, v.isSquareAttacked(kingSquare)));
    }
    return callback(new Error("game is invalid"));
  }
};

// src/algebraicGameClient.js
function getNotationPrefix(src, dest, movesForPiece) {
  let containsDest = (squares) => {
    let n = 0;
    for (; n < squares.length; n++) {
      if (squares[n] === dest) {
        return true;
      }
    }
    return false;
  }, file = "", fileHash = {}, i = 0, prefix = src.piece.notation, rank = 0, rankHash = {};
  for (; i < movesForPiece.length; i++) {
    if (containsDest(movesForPiece[i].squares)) {
      file = movesForPiece[i].src.file;
      rank = movesForPiece[i].src.rank;
      fileHash[file] = typeof fileHash[file] !== "undefined" ? fileHash[file] + 1 : 1;
      rankHash[rank] = typeof rankHash[rank] !== "undefined" ? rankHash[rank] + 1 : 1;
    }
  }
  if (Object.keys(fileHash).length > 1) {
    prefix += src.file;
  }
  if (Object.keys(rankHash).length > Object.keys(fileHash).length) {
    prefix += src.rank;
  }
  return prefix;
}
function getValidMovesByPieceType(pieceType, validMoves) {
  let byPiece = [], i = 0;
  for (; i < validMoves.length; i++) {
    if (validMoves[i].src.piece.type === pieceType) {
      byPiece.push(validMoves[i]);
    }
  }
  return byPiece;
}
function notate(validMoves, gameClient) {
  let algebraicNotation = {}, i = 0, isPromotion = false, movesForPiece = [], n = 0, p = null, prefix = "", sq = null, src = null, suffix = "";
  for (; i < validMoves.length; i++) {
    src = validMoves[i].src;
    p = src.piece;
    for (n = 0; n < validMoves[i].squares.length; n++) {
      prefix = "";
      sq = validMoves[i].squares[n];
      suffix = (sq.piece ? "x" : "") + sq.file + sq.rank;
      isPromotion = (sq.rank === 8 || sq.rank === 1) && p.type === PieceType.Pawn;
      if (sq.piece && p.type === PieceType.Pawn) {
        prefix = src.file;
      }
      if (p.type === PieceType.Pawn && src.file !== sq.file && !sq.piece) {
        prefix = [src.file, "x"].join("");
      }
      if (p.type === PieceType.Bishop || p.type === PieceType.Knight || p.type === PieceType.Queen || p.type === PieceType.Rook) {
        movesForPiece = getValidMovesByPieceType(p.type, validMoves);
        if (movesForPiece.length > 1) {
          prefix = getNotationPrefix(src, sq, movesForPiece);
        } else {
          prefix = src.piece.notation;
        }
      }
      if (p.type === PieceType.King) {
        if (src.file === "e" && sq.file === "g") {
          prefix = gameClient.PGN ? "O-O" : "0-0";
          suffix = "";
        } else if (src.file === "e" && sq.file === "c") {
          prefix = gameClient.PGN ? "O-O-O" : "0-0-0";
          suffix = "";
        } else {
          prefix = src.piece.notation;
        }
      }
      if (isPromotion) {
        algebraicNotation[prefix + suffix + "R"] = {
          dest: sq,
          src
        };
        algebraicNotation[prefix + suffix + "N"] = {
          dest: sq,
          src
        };
        algebraicNotation[prefix + suffix + "B"] = {
          dest: sq,
          src
        };
        algebraicNotation[prefix + suffix + "Q"] = {
          dest: sq,
          src
        };
      } else {
        algebraicNotation[prefix + suffix] = {
          dest: sq,
          src
        };
      }
    }
  }
  return algebraicNotation;
}
function parseNotation(notation) {
  let captureRegex = /^[a-h]x[a-h][1-8]$/, parseDest = "";
  parseDest = notation.substring(notation.length - 2);
  if (notation.length > 2) {
    if (captureRegex.test(notation)) {
      return parseDest;
    }
    return notation.charAt(0) + parseDest;
  }
  return "";
}
function updateGameClient(gameClient) {
  gameClient.validation.start((err, result) => {
    if (err) {
      throw new Error(err);
    }
    gameClient.isCheck = result.isCheck;
    gameClient.isCheckmate = result.isCheckmate;
    gameClient.isRepetition = result.isRepetition;
    gameClient.isStalemate = result.isStalemate;
    gameClient.notatedMoves = notate(result.validMoves, gameClient);
    gameClient.validMoves = result.validMoves;
  });
}
var AlgebraicGameClient = class _AlgebraicGameClient extends import_events3.EventEmitter {
  constructor(game, opts) {
    super();
    this.game = game;
    this.isCheck = false;
    this.isCheckmate = false;
    this.isRepetition = false;
    this.isStalemate = false;
    this.notatedMoves = {};
    this.PGN = opts && typeof opts.PGN === "boolean" ? opts.PGN : false;
    this.validMoves = [];
    this.validation = GameValidation.create(this.game);
    ["check", "checkmate"].forEach((ev) => {
      this.game.on(ev, (data) => this.emit(ev, data));
    });
    ["capture", "castle", "enPassant", "move", "promote", "undo"].forEach((ev) => {
      this.game.board.on(ev, (data) => this.emit(ev, data));
    });
    let self2 = this;
    this.on("undo", () => {
      self2.getStatus(true);
    });
  }
  static create(opts) {
    let game = Game.create(), gameClient = new _AlgebraicGameClient(game, opts);
    updateGameClient(gameClient);
    return gameClient;
  }
  static fromFEN(fen, opts) {
    if (!fen || typeof fen !== "string") {
      throw new Error("FEN must be a non-empty string");
    }
    let game = Game.create(), loadedBoard = Board.load(fen);
    for (let i = 0; i < game.board.squares.length; i++) {
      game.board.squares[i].piece = null;
    }
    for (let i = 0; i < loadedBoard.squares.length; i++) {
      let sq = loadedBoard.squares[i];
      if (sq.piece) {
        let target = game.board.getSquare(sq.file, sq.rank);
        target.piece = sq.piece;
      }
    }
    game.board.lastMovedPiece = null;
    let parts = fen.split(" ");
    let active = parts[1] || "w";
    let baseSide = active === "b" ? SideType.Black : SideType.White;
    let whiteFirst = baseSide === SideType.White;
    game.getCurrentSide = function getCurrentSideAfterFENLoad() {
      return this.moveHistory.length % 2 === 0 ? whiteFirst ? SideType.White : SideType.Black : whiteFirst ? SideType.Black : SideType.White;
    };
    const gameClient = new _AlgebraicGameClient(game, opts);
    updateGameClient(gameClient);
    return gameClient;
  }
  getStatus(forceUpdate) {
    if (forceUpdate) {
      updateGameClient(this);
    }
    return {
      board: this.game.board,
      isCheck: this.isCheck,
      isCheckmate: this.isCheckmate,
      isRepetition: this.isRepetition,
      isStalemate: this.isStalemate,
      notatedMoves: this.notatedMoves
    };
  }
  getFen() {
    return this.game.board.getFen();
  }
  getCaptureHistory() {
    return this.game.captureHistory;
  }
  move(notation, isFuzzy) {
    let move = null, notationRegex = /^[BKQNR]?[a-h]?[1-8]?[x-]?[a-h][1-8][+#]?$/, p = null, promo = "", side = this.game.getCurrentSide();
    if (notation && typeof notation === "string") {
      notation = notation.replace(/\!/g, "").replace(/\+/g, "").replace(/\#/g, "").replace(/\=/g, "").replace(/\\/g, "");
      if (this.PGN) {
        notation = notation.replace(/0/g, "O");
      } else {
        notation = notation.replace(/O/g, "0");
      }
      if (notation.charAt(notation.length - 1).match(/[BNQR]/)) {
        promo = notation.charAt(notation.length - 1);
      }
      if (this.notatedMoves[notation]) {
        move = this.game.board.move(
          this.notatedMoves[notation].src,
          this.notatedMoves[notation].dest,
          notation
        );
      } else if (notation.match(notationRegex) && notation.length > 1 && !isFuzzy) {
        return this.move(parseNotation(notation), true);
      } else if (isFuzzy) {
        throw new Error(`Invalid move (${notation})`);
      }
      if (move) {
        if (promo) {
          switch (promo) {
            case "B":
              p = Piece.createBishop(side);
              break;
            case "N":
              p = Piece.createKnight(side);
              break;
            case "Q":
              p = Piece.createQueen(side);
              break;
            case "R":
              p = Piece.createRook(side);
              break;
            default:
              p = Piece.createPawn(side);
          }
          if (p) {
            this.game.board.promote(move.move.postSquare, p);
          }
        }
        updateGameClient(this);
        return move;
      }
    }
    throw new Error(`Notation is invalid (${notation})`);
  }
};

// src/simpleGameClient.js
var import_events4 = require("events");
function isMoveValid(src, dest, validMoves) {
  let i = 0, isFound = (expr, sq) => {
    return typeof expr === "string" && sq.file + sq.rank === expr || expr && expr.rank && expr.file && sq.file === expr.file && sq.rank === expr.rank;
  }, squares = [];
  for (i = 0; i < validMoves.length; i++) {
    if (isFound(src, validMoves[i].src)) {
      squares = validMoves[i].squares;
    }
  }
  if (squares && squares.length > 0) {
    for (i = 0; i < squares.length; i++) {
      if (isFound(dest, squares[i])) {
        return true;
      }
    }
  }
  return false;
}
function updateGameClient2(gameClient) {
  return gameClient.validation.start((err, result) => {
    if (err) {
      throw new Error(err);
    }
    gameClient.isCheck = result.isCheck;
    gameClient.isCheckmate = result.isCheckmate;
    gameClient.isRepetition = result.isRepetition;
    gameClient.isStalemate = result.isStalemate;
    gameClient.validMoves = result.validMoves;
  });
}
var SimpleGameClient = class _SimpleGameClient extends import_events4.EventEmitter {
  constructor(game) {
    super();
    this.isCheck = false;
    this.isCheckmate = false;
    this.isRepetition = false;
    this.isStalemate = false;
    this.game = game;
    this.validMoves = [];
    this.validation = GameValidation.create(this.game);
    ["check", "checkmate"].forEach((ev) => {
      this.game.on(ev, (data) => this.emit(ev, data));
    });
    ["capture", "castle", "enPassant", "move", "promote"].forEach((ev) => {
      this.game.board.on(ev, (data) => this.emit(ev, data));
    });
  }
  static create() {
    let game = Game.create(), gameClient = new _SimpleGameClient(game);
    updateGameClient2(gameClient);
    return gameClient;
  }
  getStatus(forceUpdate) {
    if (forceUpdate) {
      updateGameClient2(this);
    }
    return {
      board: this.game.board,
      isCheck: this.isCheck,
      isCheckmate: this.isCheckmate,
      isRepetition: this.isRepetition,
      isStalemate: this.isStalemate,
      validMoves: this.validMoves
    };
  }
  move(src, dest, promo) {
    let move = null, side = this.game.getCurrentSide();
    if (src && dest && isMoveValid(src, dest, this.validMoves)) {
      move = this.game.board.move(src, dest);
      if (move) {
        if (promo) {
          let piece;
          switch (promo) {
            case "B":
              piece = Piece.createBishop(side);
              break;
            case "N":
              piece = Piece.createKnight(side);
              break;
            case "Q":
              piece = Piece.createQueen(side);
              break;
            case "R":
              piece = Piece.createRook(side);
              break;
            default:
              piece = null;
              break;
          }
          if (piece) {
            this.game.board.promote(move.move.postSquare, piece);
          }
        }
        updateGameClient2(this);
        return move;
      }
    }
    throw new Error(`Move is invalid (${src} to ${dest})`);
  }
  getCaptureHistory() {
    return this.game.captureHistory;
  }
};

// src/uciGameClient.js
var import_events5 = require("events");
function parseUCI(uci) {
  if (typeof uci !== "string") {
    return null;
  }
  let formatRegex = /^([a-h][1-8])([a-h][1-8])([qrbnQRBN])?$/, uciMove = uci.trim().match(formatRegex);
  if (!uciMove) {
    return null;
  }
  let dest = { file: uciMove[2][0], rank: Number(uciMove[2][1]) }, promo = uciMove[3] ? uciMove[3].toUpperCase() : "", src = { file: uciMove[1][0], rank: Number(uciMove[1][1]) };
  return { dest, promo, src };
}
function updateGameClient3(gameClient) {
  return gameClient.validation.start((err, result) => {
    if (err) {
      throw new Error(err);
    }
    gameClient.isCheck = result.isCheck;
    gameClient.isCheckmate = result.isCheckmate;
    gameClient.isRepetition = result.isRepetition;
    gameClient.isStalemate = result.isStalemate;
    gameClient.validMoves = result.validMoves;
    gameClient.uciMoves = notateUCI(result.validMoves);
  });
}
function notateUCI(validMoves) {
  let i = 0, isPromotion = false, notation = {};
  for (; i < validMoves.length; i++) {
    let p = validMoves[i].src.piece, src = validMoves[i].src;
    for (let n = 0; n < validMoves[i].squares.length; n++) {
      let sq = validMoves[i].squares[n];
      let base = `${src.file}${src.rank}${sq.file}${sq.rank}`;
      isPromotion = (sq.rank === 8 || sq.rank === 1) && p.type === PieceType.Pawn;
      if (isPromotion) {
        ["q", "r", "b", "n"].forEach((promo) => {
          notation[`${base}${promo}`] = {
            dest: sq,
            src
          };
        });
        continue;
      }
      notation[base] = {
        dest: sq,
        src
      };
    }
  }
  return notation;
}
var UCIGameClient = class _UCIGameClient extends import_events5.EventEmitter {
  constructor(game) {
    super();
    this.game = game;
    this.isCheck = false;
    this.isCheckmate = false;
    this.isRepetition = false;
    this.isStalemate = false;
    this.uciMoves = {};
    this.validMoves = [];
    this.validation = GameValidation.create(this.game);
    ["check", "checkmate"].forEach((ev) => {
      this.game.on(ev, (data) => this.emit(ev, data));
    });
    ["capture", "castle", "enPassant", "move", "promote", "undo"].forEach((ev) => {
      this.game.board.on(ev, (data) => this.emit(ev, data));
    });
    const self2 = this;
    this.on("undo", () => {
      self2.getStatus(true);
    });
  }
  static create() {
    let game = Game.create(), gameClient = new _UCIGameClient(game);
    updateGameClient3(gameClient);
    return gameClient;
  }
  getStatus(forceUpdate) {
    if (forceUpdate) {
      updateGameClient3(this);
    }
    return {
      board: this.game.board,
      isCheck: this.isCheck,
      isCheckmate: this.isCheckmate,
      isRepetition: this.isRepetition,
      isStalemate: this.isStalemate,
      uciMoves: this.uciMoves
    };
  }
  getCaptureHistory() {
    return this.game.captureHistory;
  }
  move(uci) {
    let canonical = null, dest = null, move = null, parsed = parseUCI(uci), promo = null, requiresPromotion = false, side = null, src = null, srcSquare = null;
    if (!parsed) {
      throw new Error(`UCI is invalid (${uci})`);
    }
    ({ src, dest, promo } = parsed);
    canonical = promo ? `${src.file}${src.rank}${dest.file}${dest.rank}${promo.toLowerCase()}` : `${src.file}${src.rank}${dest.file}${dest.rank}`;
    if (!this.uciMoves || !this.uciMoves[canonical]) {
      throw new Error(`Move is invalid (${uci})`);
    }
    side = this.game.getCurrentSide();
    srcSquare = this.game.board.getSquare(src.file, src.rank);
    requiresPromotion = srcSquare && srcSquare.piece && srcSquare.piece.type === PieceType.Pawn && (dest.rank === 8 || dest.rank === 1);
    if (requiresPromotion && !promo) {
      throw new Error(`Promotion required for move (${uci})`);
    }
    if (promo && !requiresPromotion) {
      throw new Error(`Promotion flag not allowed for move (${uci})`);
    }
    move = this.game.board.move(`${src.file}${src.rank}`, `${dest.file}${dest.rank}`);
    if (move) {
      if (promo) {
        let piece;
        switch (promo) {
          case "B":
            piece = Piece.createBishop(side);
            break;
          case "N":
            piece = Piece.createKnight(side);
            break;
          case "Q":
            piece = Piece.createQueen(side);
            break;
          case "R":
            piece = Piece.createRook(side);
            break;
          default:
            piece = null;
            break;
        }
        if (piece) {
          this.game.board.promote(move.move.postSquare, piece);
        }
      }
      updateGameClient3(this);
      return move;
    }
    throw new Error(`Move is invalid (${uci})`);
  }
};

// src/main.js
var create = (opts) => AlgebraicGameClient.create(opts);
var createSimple = () => SimpleGameClient.create();
var fromFEN = (fen, opts) => AlgebraicGameClient.fromFEN(fen, opts);
var createUCI = () => UCIGameClient.create();
var main_default = {
  create,
  createSimple,
  createUCI,
  fromFEN
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  create,
  createSimple,
  createUCI,
  fromFEN
});
